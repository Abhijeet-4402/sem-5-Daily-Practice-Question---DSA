// Last updated: 16/10/2025, 11:44:44 am
class Solution {
    public boolean isBipartite(int[][] graph) {
		Queue<BipartitePair> q = new LinkedList<>();
		HashMap<Integer, Integer> visited = new HashMap<Integer, Integer>();
		for(int i = 0; i < graph.length; i++) {
			if(visited.containsKey(i)) {
				continue;
			}
			q.add(new BipartitePair(i, 0));
			
			while(!q.isEmpty()) {
				//1. remove
					BipartitePair r = q.poll();
				//2. ignore
					
					if(visited.containsKey(r.vtx)) {
						if(visited.get(r.vtx)!=r.dist) {
							return false;
						}
						continue;
					}
				
				//3. mark visited
					visited.put(r.vtx, r.dist);
				
				//4. self work
				
				//5. add unvisited neighbours
					for(int nbrs:graph[r.vtx]) {
						if(!visited.containsKey(nbrs)) {
							q.add(new BipartitePair(nbrs, r.dist+1));
						}
					}
				
			}
		}
		return true;
	}
	
	class BipartitePair{
		int vtx;
		int dist;
		public BipartitePair(int vtx, int dist) {
			// TODO Auto-generated constructor stub
			this.vtx = vtx;
			this.dist = dist;
		}
	}
}